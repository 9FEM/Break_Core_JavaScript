# LexicalEnvironment란?

LexicalEnvironment는 식별자와 식별자에 바인딩된 값, 그리고 상위 스코프에 대한 참조를 기록하는 자료구조로 실행 컨텍스트를 구성하는 컴포넌트다.

실행 컨텍스트 스택이 코드의 실행 순서를 관리한다면, LexicalEnvironment는 스코프와 식별자를 관리한다.

VariableEnvironment와 LexicalEnvironment는
EnvironmentRecord, OuterLexicalEnvironmentReference 로 구성된다.

1. **환경 레코드 (EnvironmentRecord)**
   스코프에 포함된 식별자를 등록하고 등록된 식별자에 바인딩된 값을 관리하는 저장소다.
   환경 레코드는 소스코드의 타입에 따라 관리하는 내용에 차이가 있다.
2. **외부 렉시컬 환경에 대한 참조 (Outer Lexical Environment Reference)**
   외부 렉시컬 환경에 대한 참조는 상위 스코프를 가리킨다.
   이때 상위 스코프란 외부 렉시컬 환경, 즉 해당 실행 컨텍스트를 생성한 소스코드를 포함하는 상위 코드의 렉시컬 환경을 말한다.
   외부 렉시컬 환경에 대한 참조를 통해 단방향 링크드 리스트인 스코프 체인을 구현한다.

```
  * 단방향 링크드 리스트
	: 한쪽 방향으로만 이동 탐색할 수 있는 리스트
```

## EnvironmentRecord와 호이스팅

EnvironmentRecord에는 현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장됩니다.

컨텍스트를 구성하는 함수에 지정된 매개변수 식별자, 선언한 함수가 있을 경우 그 함수 자체, var로 선언된 변수의 식별자 등이 식별자에 해당합니다.

컨텍스트 내부 전체를 처음부터 끝까지 쭉 훑어나가며 `순서대로` 수집합니다.

(⇒ 코드가 실행되기 전임에도 불구하고 자바스크립트 엔진은 이미 해당 환경에 속한 코드의 변수명들을 이미 알고 있습니다.)

엔진이 실제로 끌어올리지는 않지만, 편의상 끌어올린 것으로 간주하자는 뜻에서 `호이스팅` 개념이 등장합니다.

호이스팅: `hoist` + `-ing` , 변수 정보를 수집하는 과정을 더욱 이해하기 쉬운 방법으로 대체한 가상의 개념입니다.

<br>

---

<br>

## 호이스팅 규칙

**호이스팅 예제- 매개변수와 변수에 대한 호이스팅**

1. **원본 코드** - 매개변수와 변수에 대한 호이스팅(1)

```jsx
function a(x) {
  //수집 대상 1(매개변수)
  console.log(x); //(1)-?
  var x; //수집 대상 2(변수 선언)
  console.log(x); //(2)-?
  var x = 2; //수집 대상3(변수 선언)
  console.log(x); //(3)-?
}

a(1);
```

- (1)에는 함수 `a(1)`에서 전달한 **1**이 출력, (2)는 선언된 변수가 없으므로 **undefined**가 출력, (3)에서는 **2**가 출력될 것으로 예상
- 위와 같이 인자들과 함께 함수를 호출한 경우의 동작은 arguments에 전달된 인자를 담는 것을 제외하면 코드 내부에서 변수를 선언한 것과 다른 점이 없다.

1. **매개변수를 변수 선언/할당과 같다고 간주해서 변환한 상태**

   -매개변수와 변수에 대한 호이스팅(2)

```jsx
function a(){
	**var x=1;**//수집 대상 1(매개변수 선언)
	console.log(x);//(1)
	var x;//수집 대상 2(변수 선언)
	console.log(x);//(2)
	var x=2;//수집 대상3(변수 선언)
	console.log(x); //(3)
}
a();
```

- 이 상태에서 변수를 수집하는 과정, 즉 호이스팅 처리를 해보기
- environment Record는 현재 실행될 컨텍스트의 대상 코드 내에 **어떤 식별자**들이 있는지에만 관심이 있고, 어떤 값이 할당될 것인지는 관심이 없음

- 따라서 변수를 호이스팅할 때 **변수명**만 끌어올리고 할당 과정은 원래 자리에 남겨둠

1. **호이스팅을 마친 상태** - 매개변수와 변수에 대한 호이스팅(3)

```jsx
function a() {
  var x;
  //수집 대상 1의 변수 선언 부분 -> 변수 x 선언. 메모리에서는 저장할 공간 미리 확보, 확보한 공간의 주솟값을 변수 x에 연결

  var x;
  //수집 대상 2의 변수 선언 부분 -> 다시 변수 x 선언. 이미 선언된 변수 x가 있으므로 무시

  var x;
  //수집 대상 3의 변수 선언 부분 -> 다시 변수 x 선언. 이미 선언된 변수 x가 있으므로 무시

  x = 1;
  //수집 대상 1의 할당 부분 -> x에 1을 할당하라고 함. 우선 숫자1을 별도의 메모리에 담고, x와 연결된 메모리 공간에 숫자1을 가리키는 주솟값을 입력

  console.log(x); //(1)-> **1 출력**
  console.log(x); //(2)-> **1 출력**
  x = 2;
  //수집 대상 3의 할당 부분 -> 2를 별도의 메모리에 담고, 그 주소값을 든 채로 x와 연결된 메모리 공간으로 갑니다/ 1을 가리키는 주솟값에서 2의 주솟값으로 대치

  console.log(x);
  //(3)-> **2 출력** 후 실행 컨텍스트가 콜 스택에서 제거됨
}
a(1);
```

- 호이스팅이 되었기 때문에 실제 결과 값은 (1) 1, (2) 1, (3) 2

  **-함수 선언의 호이스팅**

1. **원본코드** - 함수 선언의 호이스팅(1)

```jsx
function a() {
  console.log(b); //(1)-?
  var b = "bbb"; //수집 대상 1 (변수 선언)
  console.log(b); //(2)-?
  function b() {} //수집 대상 2 (함수 선언)
  console.log(x); //(3)-?
}
a();
```

- (1)에는 b의 값이 없으니 **에러 또는 undefined**, (2) **‘bbb’**, (3) **b함수**가 출력될 것으로 예상

- a 함수를 실행하는 순간 a 함수의 실행 컨텍스트가 생성
- 이때 변수명과 함수 선언의 정보를 위로 끌어올림(수집)
- **변수**는 선언부와 할당부를 나누어 **선언부**만 끌어올리는 반면 **함수**는 **함수 전체**를 끌어올림

1. **호이스팅을 마친 상태** - 함수선언의 호이스팅(2)

```jsx
function a() {
  var b; //수집 대상 1.변수는 선언부만 끌어올립니다.
  function b() {} //수집 대상 2.함수 선언은 전체를 끌어올립니다

  console.log(b); //(1)
  b = "bbb"; // **변수의 할당부는 원래 자리에 남겨둡니다**.
  console.log(b); //(2)
  console.log(b); //(3)
}
```

- 호이스팅이 끝난 상태에서의 함수 선언문은 함수명으로 선언한 변수에 함수를 할당한 것처럼 여길 수 있음

1. **함수 선언문을 함수 표현식으로 바꾼 코드** - 함수 선언의 호이스팅(3)

```jsx
function a() {
  var b;
  //변수 b를 선언, 메모리에서는 저장할 공간을 미리 확보하고 확보한 공간의 주솟값을 변수 b에 연결

  var b = function b() {};
  //다시 변수 b를 선언하고 함수 b를 할당하라고 함. 이미 선언된 변수가 있으므로 선언 과정은 무시, 함수는 별도의 메모리에 담기고 그 함수가 저장된 주솟값을 b와 연결된 공간에 저장.

  console.log(b);
  //(1)-b 함수 출력

  b = "bbb";
  //함수가 담긴 주솟값에서 문자열 'bbb'가 담긴 주솟값으로 덮어씀 . 이제 문자열 'bbb'를 가리키게 됨

  console.log(b); //(2)-'bbb' 출력
  console.log(b);
  //(3)-'bbb' 출력 후 실행 컨텍스트가 콜 스택에서 제거됨.
}
```

- 실제 결과 값은 (1) b 함수, (2) ‘bbb’, (3) ‘bbb’

<aside>
💡 코드가 실행되기 전임에도 불구하고 자바스크립트 엔진은 이미 해당 환경에 속한 코드의 변수명을 알고 있기 때문에 이런 결과 값이 나온다(호이스팅)

</aside>

<br>

---

<br>

## 함수 선언문과 함수 표현식

호이스팅에서 헷갈릴 수 있는 함수 선언문과 함수 표현식에 대해 알아보겠습니다. 모두 함수를 새롭게 정의할 때 쓰이는 방식인 것은 동일합니다.

**차이점과 특징**

**함수 선언문**

- 함수 선언문은 function 정의부에만 존재하고 별도의 할당 명령이 없는 것을 의미한다.
  - 정의부란? 함수를 정의하는 코드 블럭. 함수의 이름, 매개변수, 반환값의 자료형, 함수 몸체 등을 포함한다.
- 함수 선언문은 반드시 함수명이 정의 되어야한다.
- 함수 선언문은 식이 아닌 문이다. 콘솔에서 함수 선언문을 실행하면 완료 값 undefined가 출력된다. 그렇기에 표현식이 아닌 문은 변수에 할당할 수 없다.
- 함수 선언문은 정의 한다. 함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당된다.

**함수 표현식**

- 함수 표현식은 정의한 function을 별도의 변수에 할당한다.
- 함수 표현식은 함수명이 없어도 된다.
  - 함수명을 정의한 함수 표현식을 `기명 함수 표현식` 이라 하며
  - 정의하지 않은 함수 표현식을 `익명 함수 표현식` 이라고 부른다.
- 일반적인 함수 표현식은 `익명 함수 표현식` 을 뜻한다.
- 함수 표현식은 선언한다.

**함수 정의 방식**

```jsx
// 1️⃣ 함수 선언문
function 흔들기(x, y) {
  return x + y;
}
// 함수명 흔들기가 곧 변수명이 된다.

흔들기(1, 2); // 함수 실행 방법. 실행 OK

// 2️⃣ 함수 표현식 (익명)
const 도경 = function (x, y) {
  return x + y;
};
// 변수명 도경이 곧 함수명.

도경(1, 2); // 실행 OK

// 3️⃣ 함수 표현식 (기명)
const 소연 = function 병현(x, y) {
  return x + y;
};
// 변수명은 소연, 함수명은 병현.

소연(1, 2); // 실행 OK
병현(1, 2); // error!!!

// 4️⃣ Function 생성자 함수
let 도하 = new Function("x", "y", "return x + y");

// 5️⃣ 화살표 함수 (ES6)
let 도하 = (x, y) => x + y;
```

<aside>
❗ 기명 함수 표현식의 주의 할 점

외부에서는 함수명으로 함수를 호출할 수 없다는 것. 오직 내부에서만 접근 가능하다. 과거 익명 함수표현식이 undefined 또는 unnamed라는 값이 나왔었기에 기명 함수 표현식이 디버깅시 추적하기 유리했었다. 하지만 지금은 브라우저들이 익명 함수 표현식의 변수명을 함수의 name 프로퍼티에 할당하고 있다. 소연 함수에서는 `소연()`과 `병현()` 둘 다 잘 실행된다. 재귀함수를 호출하는 용도로 사용할 수 있겠지만, `소연()` 으로 호출해도 되기에…

</aside>

선언문과 표현식의 **찐차이**

```jsx
console.log(sum(1, 2));
console.log(plus(1, 2));

// 함수 선언문
function sum(a, b) {
  return a + b;
}

// 함수 표현식
let plus = function (a, b) {
  return a + b;
};
```

LexicalEnvironment는 두 가지의 정보를 수집한다. 여기서는 그중에서 environmentRecord의 정보 수집과정에서 발생하는 호이스팅을 살펴보고 있다. 위와 같은 코드가 작성 되었을 때 호이스팅이 어떤 순서로 일어날까?

```jsx
// 함수 선언문은 전체를 호이스팅한다.
let sum (a, b) = function sum (a, b) { return a + b; }

// 함수 표현식은 변수 선언부만 끌어올린다.
let plus;

console.log(sum(1, 2)); // 3 출력
console.log(plus(1, 2)); // ReferenceError: plus is not defined

plus = function (a, b) { return a + b; }
```

1. 메모리 공간을 확보, 확보된 공간의 주솟값을 변수 sum에 연결
2. 다른 메모리 공간 확보, 확보된 공간의 주솟값을 변수 plus에 연결
3. (1번) sum 함수를 다른 메모리 공간에 저장, 그 주솟값을 앞서 선언한 변수 sum의 공간에 할당.
   변수 sum ⇒ 함수 sum
4. console.log(sum(1, 2))의 실행 3이 출력
5. console.log((plus(1, 2))의 실행, 값이 할당되어 있지 않기에 비어있는 대상을 함수로 여겨 실행하라고 명령한 것. 뒤로는 에러로 인해 실행되지 않는다.

큰 차이는 함수 선언문는 함수 전체를 호이스팅한 반면, 함수 표현식은 변수 선언부만 호이스팅이 되었다. 함수도 하나의 값으로 취급할 수 있다는 것. `함수를 다른 변수에 값으로써 '할당'한 것이 곧 함수 표현식` 이다.

<aside>
❗ 함수 선언문은 선언 전에 호출해도 아무 문제 없이 실행되어서 편하게 사용될 수 있다는 장점이 있지만 가끔씩 큰 혼란을 가져오기도 한다.

</aside>

<br>
<br>

### 함수 표현식이 안전한 이유

개발자 “도하”가 더하기 함수를 선언했다. 인자 두 개를 받아서 더해주는 함수이다. 50번째 줄에 함수를 선언하고 이곳저곳에서 활용해왔다. 근데 어느날 새로 입사한 “서영”이 도하와 같은 파일의 500번째 줄에서 더하기 함수를 새로 선언했다. 서로 곱한 값을 더해주는 함수였던 것..!

```jsx
//50번째 줄
function 더하기(x, y) {
  return x + y;
}

/*

다양한 코드들 

*/

// 500번째 줄

function 더하기(x, y) {
  return x * y + x * y;
}
```

위와 같은 경우 동일한 변수명에 서로 다른 값을 할당할 경우 나중에 할당한 값이 먼저 할당한 값을 덮어 씌우게 된다. 따라서 코드를 실행하는 중에 실제로 호출되는 함수는 마지막 더하기 함수이다. 만약 이 함수를 함수 표현식으로 작성했다면 어땠을까?

```jsx
//50번째 줄
let 더하기 = function (x, y) {
  return x + y;
};

console.log(더하기(2, 2)); // 4

// 500번째 줄

let 더하기 = function (x, y) {
  return x * y + x * y;
};

console.log(더하기(2, 2)); // 8
```

위 코드 처럼 서로의 의도대로 잘 작동했을 것이다. 잘못된 곳에서 호출할 경우 error를 띄워주기 때문에 디버깅 역시 편할 것이다.

마지막으로 정리하자면,

- 함수 표현식은 변수 선언부만 호이스팅 된다. 변수 할당문의 값은 할당문이 실행되는 시점, 런타임에 평가된다. 그렇기에 함수 정의 전 호출하면 error가 발생한다.
- 함수 선언문은 함수 전체가 호이스팅 된다. 함수 정의 전, 호출해도 정상작동 한다.
